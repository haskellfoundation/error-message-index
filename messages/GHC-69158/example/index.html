<h2 id="error-message">Error Message</h2>
<pre><code>Greeting.hs:3:5: error: [GHC-69158]
    Conflicting exports for ‘greeting’:
       ‘W.greeting’ exports ‘W.greeting’
         imported qualified from ‘World’ at Greeting.hs:6:1-27
         (and originally defined at World.hs:4:1-8)
       ‘U.greeting’ exports ‘U.greeting’
         imported qualified from ‘Universe’ at Greeting.hs:7:1-30
         (and originally defined at Universe.hs:4:1-8)
  |
3 |   , U.greeting
  |     ^^^^^^^^^^</code></pre>
<h2 id="explanation">Explanation</h2>
<p>This examples defines the modules <code>World</code> and <code>Universe</code>, both of which export
an identifier named <code>greeting</code>. The <code>Greeting</code> module then imports <code>World</code> and
<code>Universe</code> qualified, meaning it can use both identifiers named <code>greeting</code> in
the body of <code>bothGreetings</code> without any ambiguity. However, the export of both
<code>greeting</code>s in <code>Greeting</code>’s export list does cause ambiguity, because a module
can only export one identifier with a given name.</p>
<p>In this case, we decide that we want to export just one default greeting, and
that most users of our code won’t need to greet the entire universe. Therefore,
we fix the error by removing the re-export of <code>U.greeting</code>.</p>
<p>If we still want to somehow export <code>U.greeting</code> in addition to <code>W.greeting</code>,
we’ll have to define a new identifier and set it equal to <code>U.greeting</code>, and then
export that instead. For example, we could define
<code>universalGreeting = U.greeting</code> in the body of <code>Greeting</code>.</p>

<table width="100%">
  
  <tr><td colspan="2" class="filename"><pre>Greeting.hs</pre></td></tr>
  <tr>
    <td width="50%" class="beforeafter">Before</td>
    <td width="50%" class="beforeafter">After</td>
  </tr>
  <tr>
    <td>
      <pre><code class="language-haskell">module Greeting
  ( W.greeting
  , U.greeting
  ) where

import qualified World as W
import qualified Universe as U

bothGreetings :: String
bothGreetings = unlines [W.greeting, U.greeting]
</code></pre>
    </td>
    <td>
      <pre><code class="language-haskell">module Greeting
  ( W.greeting
  ) where

import qualified World as W
import qualified Universe as U

bothGreetings :: String
bothGreetings = unlines [W.greeting, U.greeting]
</code></pre>
    </td>
  </tr>
  
  <tr><td colspan="2" class="filename"><pre>Universe.hs</pre></td></tr>
  <tr>
    <td width="50%" class="beforeafter">Before</td>
    <td width="50%" class="beforeafter">After</td>
  </tr>
  <tr>
    <td>
      <pre><code class="language-haskell">module Universe where

greeting :: String
greeting = "Hello, Universe!"
</code></pre>
    </td>
    <td>
      <pre><code class="language-haskell">module Universe where

greeting :: String
greeting = "Hello, Universe!"
</code></pre>
    </td>
  </tr>
  
  <tr><td colspan="2" class="filename"><pre>World.hs</pre></td></tr>
  <tr>
    <td width="50%" class="beforeafter">Before</td>
    <td width="50%" class="beforeafter">After</td>
  </tr>
  <tr>
    <td>
      <pre><code class="language-haskell">module World where

greeting :: String
greeting = "Hello, World!"
</code></pre>
    </td>
    <td>
      <pre><code class="language-haskell">module World where

greeting :: String
greeting = "Hello, World!"
</code></pre>
    </td>
  </tr>
  
</table>
