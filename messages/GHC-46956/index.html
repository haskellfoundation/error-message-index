<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Kind variable would escape its scope [GHC-46956] — Haskell Error Index</title>
  <link rel="stylesheet" href="../../css/highlight.css">
  <script src="../../js/highlight.min.js"></script>
  <link rel="stylesheet" href="../../css/default.css" />
  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="canonical" href="../../messages/GHC-46956/" />
</head>

<body>
  <main role="main">
    <nav class="breadcrumb">
      
      <a href="../../">The Haskell Error Index</a>&nbsp;»
      
      Kind variable would escape its scope [GHC-46956]
    </nav>
    <h1>Kind variable would escape its scope [GHC-46956]</h1>
    

<p>This error occurs during kind inference. When inferring a kind for a type variable, GHC creates a fresh metavariable to stand for the kind. Later, if something forces this kind metavariable to be equal to some other kind, unification equates them. However, local kind quantification can lead to the existence of kinds that are only valid in the scope of the quantifier. If a kind metavariable that originated outside this scope were unified with the locally-bound kind, then the resulting program would contain an ill-scoped kind signature.</p>
<p>This situation can arise for multiple reasons.
- In the first example, the cause is a manually-specified type signature with the kind variable in the wrong position.
- In the second example, the cause is a pattern match on a GADT constructor in a <code>let</code> binding (use <code>case</code> instead).</p>



<h2>Examples</h2>

<details open="open">
  <summary>An escaping kind variable</summary>
  <div class="details-inner">
    <h2 id="error-message">Error Message</h2>
<pre><code>Main.hs:9:49: error: [GHC-46956]
    • Expected kind ‘k’, but ‘b’ has kind ‘k0’
    • because kind variable ‘k’ would escape its scope
    This (rigid, skolem) kind variable is bound by
      an explicit forall k (a :: k)
      at Main.hs:9:26-35
    • In the second argument of ‘SameKind’, namely ‘b’
      In the type signature:
        foo :: forall b. (forall k (a :: k). SameKind a b) -&gt; ()
  |
9 | foo :: forall b. (forall k (a :: k). SameKind a b) -&gt; ()
  |                                                 ^</code></pre>
<h2 id="explanation">Explanation</h2>
<p>In this context, the <code>SameKind</code> type requires that both of its arguments are types, and that those types have the same kind. In <code>foo</code>’s type signature, the type <code>b</code> does not have an explicitly-provided kind, which means that GHC creates a fresh kind metavariable for it. The type <code>a</code> does have an explicit kind, which is the variable <code>k</code>. Because <code>SameKind</code> is applied to both <code>a</code> and <code>b</code>, it causes <code>b</code>’s kind metavariable to be unified with <code>k</code>, but <code>k</code> comes from an inner scope and is thus not available for unification.</p>
<p>The error can be fixed by extending <code>k</code>’s scope to encompass <code>b</code>’s binding site.</p>

<pre class="filename">Main.hs</pre>
<div class="example-container">
  <div class="example">
    <div class="example-inner">
      <div class="example-title">Before</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format properly -->
      <pre class="example-pre"><code class="language-haskell">{-# LANGUAGE PolyKinds, RankNTypes, ImpredicativeTypes #-}

module Main where

import Data.Kind

data SameKind :: k -> k -> *

foo :: forall b. (forall k (a :: k). SameKind a b) -> ()
foo = undefined

main :: IO ()
main = pure ()
</code></pre>
    </div>
  </div>
  <div class="example">
    <div class="example-inner">
      <div class="example-title">After</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format propertly -->
      <pre class="example-pre"><code class="language-haskell">{-# LANGUAGE PolyKinds, RankNTypes, ImpredicativeTypes #-}

module Main where

import Data.Kind

data SameKind :: k -> k -> *

foo :: forall k b. (forall (a :: k). SameKind a b) -> ()
foo = undefined

main :: IO ()
main = pure ()
</code></pre>
    </div>
  </div>
</div>


  </div>
</details>

<details open="open">
  <summary>Binding a `GADT` constructor in `let`</summary>
  <div class="details-inner">
    <p>In this example, we use a <code>let</code> binding to unpack the constructor of a GADT. Naively, this should work fine, because there is only one constructor. Yet GHC does not accept this code!</p>
<p>The fix is to use pattern-matching, either with a <code>case</code> or by pattern-matching in a function argument.</p>
<p>For more details about why this is necessary, see the <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/existential_quantification.html#restrictions">GHC user guide on ExistentialQuantification</a>.</p>
<p>Note: this example generates GHC-46956 because the <code>TypeFamilies</code> extension is active. If it isn’t, <a href="../../../messages/GHC-25897">GHC-25897</a> is generated instead.</p>
<h2 id="message">Message</h2>
<pre><code>Let.hs:9:18: error: [GHC-46956]
    • Couldn't match expected type ‘a0’ with actual type ‘a’
        because type variable ‘a’ would escape its scope
      This (rigid, skolem) type variable is bound by
        a pattern with constructor:
          MkShowable :: forall a. Show a =&gt; a -&gt; Showable,
        in a pattern binding
        at Let.hs:9:7-18
    • In the pattern: MkShowable x
      In a pattern binding: MkShowable x = showable
      In the expression: let MkShowable x = showable in show x
  |
9 |   let MkShowable x = showable
  |                  ^</code></pre>

<pre class="filename">Let.hs</pre>
<div class="example-container">
  <div class="example">
    <div class="example-inner">
      <div class="example-title">Before</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format properly -->
      <pre class="example-pre"><code class="language-haskell">{-# LANGUAGE TypeFamilies #-}
module Main where

data Showable where
  MkShowable :: Show a => a -> Showable

showShowable :: Showable -> String
showShowable showable =
  let MkShowable x = showable
  in show x

main :: IO ()
main = putStrLn $ showShowable (MkShowable 42)
</code></pre>
    </div>
  </div>
  <div class="example">
    <div class="example-inner">
      <div class="example-title">After</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format propertly -->
      <pre class="example-pre"><code class="language-haskell">{-# LANGUAGE TypeFamilies #-}
module Main where

data Showable where
  MkShowable :: Show a => a -> Showable

showShowable :: Showable -> String
showShowable showable =
  case showable of
    MkShowable x -> show x

main :: IO ()
main = putStrLn $ showShowable (MkShowable 42)
</code></pre>
    </div>
  </div>
</div>


  </div>
</details>



  </main>

  <footer>
    <p class="HF foot">
      This site is a project of <a href="https://haskell.foundation" target="_blank" rel="noopener noreferrer">The
        Haskell Foundation</a>.
    </p>
    <p class="shoutout foot">
      Site proudly generated by
      <a href="http://jaspervdj.be/hakyll" target="_blank" rel="noopener noreferrer">Hakyll</a>
    </p>
  </footer>

  <script>document.querySelectorAll('code.language-haskell').forEach(el => {
      hljs.highlightElement(el);
    });</script>
</body>

</html>
