<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex">
  <title>User-defined type error [GHC-64725] — Haskell Error Index</title>
  <link rel="stylesheet" href="../../css/highlight.css">
  <script src="../../js/highlight.min.js"></script>
  <link rel="stylesheet" href="../../css/default.css" />
  <link rel="stylesheet" href="../../css/theme.css" />
</head>

<body>
  <main role="main">
    <nav class="breadcrumb">
      
      <a href="../../">The Haskell Error Index</a>&nbsp;»
      
      User-defined type error [GHC-64725]
    </nav>
    <h1>User-defined type error [GHC-64725]</h1>
    

<p>Errors like this usually come from libraries trying to enforce certain
rules about the types they work with, or to improve upon a compiler error that
would occur otherwise. It is up to the library authors to provide enough
information in the embedded error message to fix the failing program—check
the documentation for the function that triggered the error for more
information.
These errors are constructed using <code>GHC.TypeLits.TypeError</code> applied to a type
level error message as the context of a class instance, and the compiler
will show them when a program attempts to use such an instance.</p>



<h2>Examples</h2>

<details open="open">
  <summary>Cannot Display functions</summary>
  <div class="details-inner">
    <h2 id="error-message">Error Message</h2>
<pre><code>Main2.hs:12:23: error: [GHC-64725]
    • Cannot display functions.
      Perhaps there are missing arguments?
    • In the expression: display myFunction
      In an equation for ‘myDisplayedFunction’:
          myDisplayedFunction = display myFunction
   |
12 | myDisplayedFunction = display myFunction
   |                       ^^^^^^^</code></pre>
<h2 id="explanation">Explanation</h2>
<p>Here, the module <code>SomeDisplayLibrary</code> stands in for a pretty-printing library,
used to produce human readable text from Haskell values. The library provides a
type class <code>Display</code> with instances for different types with a function
<code>display :: Display a =&gt; a -&gt; String</code> to perform the conversion. In this case
the result is of type <code>String</code> but some libraries use their own data type to
structure the output.</p>
<p>A problem common to these libraries is that of function typed values, since
there’s no general way to represent them as strings. Perhaps for <em>some</em>
functions one could simply write the mapping from inputs to outputs - if the input space is enumerable and small enough - but it becomes impractical for larger types, and unfeasible for non-enumerable types. Usually these libraries don’t provide an instance for functions. In this case, the library
authors did provide an instance, but one that gives a compile time error with more information than just “<code>No instance for (Display (Bool -&gt; Int))</code>.”</p>
<p>Depending on context, the solution could be to follow the error message and
display the result of applying the function to enough arguments, see
<code>myDisplayedAppliedFunction</code>.</p>
<p>If the intention was to actually display the function when the input space is small enough (e.g. just the two <code>Bool</code> constructors), one could define a newtype for functions of type <code>Bool -&gt; a</code> and provide a <code>Display</code> instance for it. Then, the user can call <code>display</code> with the function wrapped in this newtype, see <code>myDisplayedNewtypedFunction</code>.</p>

<pre class="filename">Main2.hs</pre>
<div class="example-container">
  <div class="example">
    <div class="example-inner">
      <div class="example-title">Before</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format properly -->
      <pre class="example-pre"><code class="language-haskell">module Main2 where

import SomeDisplayLibrary (Display (..))

myFunction :: Bool -> Int
myFunction x =
  if x
    then 42
    else 54

myDisplayedFunction :: String
myDisplayedFunction = display myFunction
</code></pre>
    </div>
  </div>
  <div class="example">
    <div class="example-inner">
      <div class="example-title">After</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format propertly -->
      <pre class="example-pre"><code class="language-haskell">module Main2 where

import SomeDisplayLibrary (Display (..))

myFunction :: Bool -> Int
myFunction x =
  if x
    then 42
    else 54

myDisplayedAppliedFunction :: String
myDisplayedAppliedFunction = display (myFunction True)

newtype BoolFun a = BoolFun (Bool -> a)

instance Display a => Display (BoolFun a) where
  display (BoolFun f) =
    "(\\x -> if x then " <> display (f True) <>
    " else " <> display (f False) <> ")"

myDisplayedNewtypedFunction :: String
myDisplayedNewtypedFunction = display (BoolFun myFunction)
</code></pre>
    </div>
  </div>
</div>

<pre class="filename">SomeDisplayLibrary.hs</pre>
<div class="example-container">
  <div class="example">
    <div class="example-inner">
      <div class="example-title">Before</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format properly -->
      <pre class="example-pre"><code class="language-haskell">{-# LANGUAGE DataKinds #-}
{-# LANGUAGE UndecidableInstances #-}

module SomeDisplayLibrary where

import GHC.TypeLits

class Display a where
  display :: a -> String

instance Display () where
  display () = "()"

instance Display Bool where
  display b = if b then "True" else "False"

instance Display Int where
  display = show

instance (Display a, Display b) => Display (a, b) where
  display (a, b) = "(" <> display a <> ", " <> display b <> ")"

instance TypeError (Text "Cannot display functions." :$$:
                    Text "Perhaps there are missing arguments?")
    => Display (a -> b) where
  display = error "unreachable: instance Display (a -> b)"
</code></pre>
    </div>
  </div>
  <div class="example">
    <div class="example-inner">
      <div class="example-title">After</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format propertly -->
      <pre class="example-pre"><code class="language-haskell">{-# LANGUAGE DataKinds #-}
{-# LANGUAGE UndecidableInstances #-}

module SomeDisplayLibrary where

import GHC.TypeLits

class Display a where
  display :: a -> String

instance Display () where
  display () = "()"

instance Display Bool where
  display b = if b then "True" else "False"

instance Display Int where
  display = show

instance (Display a, Display b) => Display (a, b) where
  display (a, b) = "(" <> display a <> ", " <> display b <> ")"

instance TypeError (Text "Cannot display functions." :$$:
                    Text "Perhaps there are missing arguments?")
    => Display (a -> b) where
  display = error "unreachable: instance Display (a -> b)"
</code></pre>
    </div>
  </div>
</div>


  </div>
</details>

<details open="open">
  <summary>Cannot encode arbitrary precision integers</summary>
  <div class="details-inner">
    <h2 id="error-message">Error Message</h2>
<pre><code>Main1.hs:9:18: error: [GHC-64725]
    • Cannot encode arbitrary precision integers.
      Consider using a fixed size representation.
    • In the expression: encode myValue
      In an equation for ‘myEncodedValue’:
          myEncodedValue = encode myValue
  |
9 | myEncodedValue = encode myValue
  |                  ^^^^^^</code></pre>
<h2 id="explanation">Explanation</h2>
<p>Here, the module <code>SomeEncodingLibrary</code> stands in for a library used to encode
Haskell values into some encoding, represented by the data type <code>Encoded</code>. The
library also provides a type class <code>Encode</code> with instances for different types,
and the function <code>encode :: Encode a =&gt; a -&gt; Encoded</code> to perform the encoding.</p>
<p>There are many such Haskell libraries depending on the target encoding.
It’s also common to find data types that don’t work for a particular encoding;
in this example, the encoding library only works with types where the size of
values is statically-known. Since, in this case, we know <code>myValue</code> fits in an
<code>Int</code>, the solution is to use that as the type of <code>myValue</code> instead of
<code>Integer</code>. However, for a program that needs to work with <code>Integer</code>s, a
different solution would be needed, likely using a different encoding
(and encoding library) altogether.</p>

<pre class="filename">Main1.hs</pre>
<div class="example-container">
  <div class="example">
    <div class="example-inner">
      <div class="example-title">Before</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format properly -->
      <pre class="example-pre"><code class="language-haskell">module Main1 where

import SomeEncodingLibrary (Encoded, encode)

myValue :: Integer
myValue = 42

myEncodedValue :: Encoded
myEncodedValue = encode myValue
</code></pre>
    </div>
  </div>
  <div class="example">
    <div class="example-inner">
      <div class="example-title">After</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format propertly -->
      <pre class="example-pre"><code class="language-haskell">module Main1 where

import SomeEncodingLibrary (Encoded, encode)

myValue :: Int
myValue = 42

myEncodedValue :: Encoded
myEncodedValue = encode myValue
</code></pre>
    </div>
  </div>
</div>

<pre class="filename">SomeEncodingLibrary.hs</pre>
<div class="example-container">
  <div class="example">
    <div class="example-inner">
      <div class="example-title">Before</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format properly -->
      <pre class="example-pre"><code class="language-haskell">{-# LANGUAGE DataKinds #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE TypeFamilies #-}

module SomeEncodingLibrary where

import GHC.TypeLits

class Encode a

data Encoded = Encoded

encode :: Encode a => a -> Encoded
encode _ = Encoded

instance Encode ()

instance Encode Bool

instance Encode Int

instance Encode Word

instance (Encode a, Encode b) => Encode (a, b)

instance TypeError (Text "Cannot encode arbitrary precision integers." :$$:
                    Text "Consider using a fixed size representation.")
    => Encode Integer
</code></pre>
    </div>
  </div>
  <div class="example">
    <div class="example-inner">
      <div class="example-title">After</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format propertly -->
      <pre class="example-pre"><code class="language-haskell">{-# LANGUAGE DataKinds #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE TypeFamilies #-}

module SomeEncodingLibrary where

import GHC.TypeLits

class Encode a

data Encoded = Encoded

encode :: Encode a => a -> Encoded
encode _ = Encoded

instance Encode ()

instance Encode Bool

instance Encode Int

instance Encode Word

instance (Encode a, Encode b) => Encode (a, b)

instance TypeError (Text "Cannot encode arbitrary precision integers." :$$:
                    Text "Consider using a fixed size representation.")
    => Encode Integer
</code></pre>
    </div>
  </div>
</div>


  </div>
</details>



  </main>

  <footer>
    <p class="HF foot">
      This site is a project of <a href="https://haskell.foundation" target="_blank" rel="noopener noreferrer">The
        Haskell Foundation</a>.
    </p>
    <p class="shoutout foot">
      Site proudly generated by
      <a href="http://jaspervdj.be/hakyll" target="_blank" rel="noopener noreferrer">Hakyll</a>
    </p>
  </footer>

  <script>document.querySelectorAll('code.language-haskell').forEach(el => {
      hljs.highlightElement(el);
    });</script>
</body>

</html>
