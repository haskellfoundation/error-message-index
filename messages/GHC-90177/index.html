<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="robots" content="noindex">
  <title>Orphan instance [GHC-90177] — Haskell Error Index</title>
  <link rel="stylesheet" href="../../css/highlight.css">
  <script src="../../js/highlight.min.js"></script>
  <link rel="stylesheet" href="../../css/default.css" />
  <link rel="stylesheet" href="../../css/theme.css" />
</head>

<body>
  <main role="main">
    <nav class="breadcrumb">
      
      <a href="../../">The Haskell Error Index</a>&nbsp;»
      
      Orphan instance [GHC-90177]
    </nav>
    <h1>Orphan instance [GHC-90177]</h1>
    
<p>
  <i>Flag: <code>-Worphans</code></i><br />
  
      
      <i>Enabled by: <code>-Wall</code></i>
      
  
</p>


<p>When writing an instance for a typeclass, the ideal situation is that this instance is defined either in the same module as the <em>typeclass</em>, or in the same module as the <em>datatype</em>. This ensures that if a module imports either the typeclass or the datatype module, the instances will also be visible.</p>
<p>If the instances are defined in a separate module, it becomes possible that the typeclass and the datatype are brought into scope but the <em>instance for that datatype</em> is not, leading to unexpected <code>No instance of Foo for type Bar</code>.</p>
<p>Whilst this is not always avoidable, it is best practice to place the instance in the module that defines either the typeclass or the datatype. However that solution is not always possible (for example in cases where both the typeclass and the data type are declared in 3rd party libraries). In such cases we can wrap the datatype in <code>newtype</code>, and then define an instance of the class for the <em>newtype</em> in the same module.</p>



<h2>Examples</h2>

<details open="open">
  <summary>Orphan instance in a separate module from definitions</summary>
  <div class="details-inner">
    <p>In this example, the implementation for <code>IsAFoo Foo</code> is in a different module than both the definition for <code>class IsAFoo</code> and the datatype <code>Foo</code>. Thus, it would be possible for a user to write <code>import Foo</code> and expect to have <code>instance IsAFoo Foo</code> in scope; however, the user would need to additionally import <code>module OrphanInstance</code>.</p>
<p>In this case, where the definitions for both the typeclass and the type are available, the solution is to move the instance definition into the <code>Foo</code> module.</p>
<h2 id="error-message">Error Message</h2>
<pre><code>OrphanInstance.hs:5:1: warning: [-Worphans] [GHC-90177]
    Orphan instance: instance IsAFoo Foo
    To avoid this
        move the instance declaration to the module of the class or of the type, or
        wrap the type with a newtype and declare the instance on the new type.
  |
5 | instance IsAFoo Foo where
  | ^^^^^^^^^^^^^^^^^^^^^^^^^...</code></pre>

<pre class="filename">Foo.hs</pre>
<div class="example-container">
  <div class="example">
    <div class="example-inner">
      <div class="example-title">Before</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format properly -->
      <pre class="example-pre"><code class="language-haskell">module Foo where

data Foo = Foo

class IsAFoo x where
    convertToFoo :: x -> Foo
</code></pre>
    </div>
  </div>
  <div class="example">
    <div class="example-inner">
      <div class="example-title">After</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format propertly -->
      <pre class="example-pre"><code class="language-haskell">module Foo where

data Foo = Foo

class IsAFoo x where
    convertToFoo :: x -> Foo

instance IsAFoo Foo where
    convertToFoo = id
</code></pre>
    </div>
  </div>
</div>

<pre class="filename">OrphanInstance.hs</pre>
<div class="example-container">
  <div class="example">
    <div class="example-inner">
      <div class="example-title">Before</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format properly -->
      <pre class="example-pre"><code class="language-haskell">module OrphanInstance where

import Foo

instance IsAFoo Foo where
    convertToFoo = id
</code></pre>
    </div>
  </div>
  <div class="example">
    <div class="example-inner">
      <div class="example-title">After</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format propertly -->
      <pre class="example-pre"><code class="language-haskell">module OrphanInstance where

import Foo
</code></pre>
    </div>
  </div>
</div>


  </div>
</details>



  </main>

  <footer>
    <p class="HF foot">
      This site is a project of <a href="https://haskell.foundation" target="_blank" rel="noopener noreferrer">The
        Haskell Foundation</a>.
    </p>
    <p class="shoutout foot">
      Site proudly generated by
      <a href="http://jaspervdj.be/hakyll" target="_blank" rel="noopener noreferrer">Hakyll</a>
    </p>
  </footer>

  <script>document.querySelectorAll('code.language-haskell').forEach(el => {
      hljs.highlightElement(el);
    });</script>
</body>

</html>
